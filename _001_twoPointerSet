---> Question solving flow :

  -> think faith >> draw recursive tree >> write recursive code >> 
     do memoization >> observation >> do tabulation >> optimization ~sometimes
  -> first flow takes the almost time and the base of DP, second flow hardly takes 3 minutes.
  -> memoization or tabulation ? - always invest yourself in memoization. intuition never comes by tabulation. also memo to tab hardly takes 3 minutes via only small changes.
  -> tabulation ? - memoization is actual DP, but when if mujhe kuch pattern observe ho raha hai. ye to shayad me iteratively bhi kar sakta hu. that is tabulation.
  -> real life dp ? - cooking something new via Yt takes time only for the first time.
  -> dp says if you have already evaluation a solution to a problem then don't solve it again, just save that solution into some space and utilise it
  
 -> fibonacci 
 
    public static int fibo_rec(int n){
        if(n <= 1){
            return n;
        }
        int fib = fibo_rec(n-1) + fibo_rec(n-2);
        return fib;
    }
    
     public static int fibo_memo(int n,int[] dp){
        if(n <= 1){
            return dp[n] = n;
        }
        if(dp[n] != 0){
            return dp[n];
        }
        int fib = fibo_memo(n-1,dp) + fibo_memo(n-2,dp);
        return dp[n] = fib;
    }
    
     public static int fibo_tab(int N,int[] dp){
        for(int n = 0 ; n <= N ; n++){
            if(n <= 1){
                dp[n] = n;
                continue;
            }
            int fib = dp[n-1] + dp[n-2];
            dp[n] = fib;
        }
        return dp[N];
    }
    
 -> maze path ways
 
     public static int mazePathWays_rec(int[][] maze,int sr,int sc,int dr,int dc,int[][] dir){
        if(sr == dr && sc == dc){
            return 1;
        }
        int ways = 0;
        for(int i = 0 ; i < dir.length ; i++){
            int r = sr + dir[i][0];
            int c = sc + dir[i][1];
            if(r <= dr && c <= dc){
               ways += mazePathWays_rec(maze , r , c , dr , dc , dir);
            }
        }
        return ways;
    }

    public static int mazePathWays_memo(int[][] maze,int sr,int sc,int dr,int dc,int[][] dir,int[][] dp){
        if(sr == dr && sc == dc){
            return dp[sr][sc] = 1;
        }
        if(dp[sr][sc] != 0){
            return dp[sr][sc];
        }
        int ways = 0;
        for(int i = 0 ; i < dir.length ; i++){
            int r = sr + dir[i][0];
            int c = sc + dir[i][1];
            if(r <= dr && c <= dc){
               ways += mazePathWays_memo(maze , r , c , dr , dc , dir , dp);
            }
        }
        return dp[sr][sc] = ways;
    }

    public static int mazePathWays_tab(int[][] maze,int SR,int SC,int DR,int DC,int[][] dir,int[][] dp){
        for(int sr = DR ; sr >= SR ; sr--){
            for(int sc = DC ; sc >= SC ; sc--){
                if(sr == DR && sc == DC){
                    dp[sr][sc] = 1;
                    continue;
                }
                int ways = 0;
                for(int i = 0 ; i < dir.length ; i++){
                    int r = sr + dir[i][0];
                    int c = sc + dir[i][1];
                    if(r <= DR && c <= DC){
                        ways += dp[r][c];
                    }
                }
                dp[sr][sc] = ways;
            }
        }
        return dp[SR][SC];
    }
    
 -> maze path with jumps ways
 
     public static int mazePathJumpWays_rec(int[][] maze,int sr,int sc,int dr,int dc,int[][] dir){
        if(sr == dr && sc == dc){
            return 1;
        }
        int ways = 0;
        for(int i = 0 ; i < dir.length ; i++){
            int r = sr + dir[i][0];
            int c = sc + dir[i][1];
            while(r <= dr && c <= dc){
               ways += mazePathJumpWays_rec(maze , r , c , dr , dc , dir);
               r += dir[i][0];
               c += dir[i][1];
            }
        }
        return ways;
    }
    
    public static int mazePathJumpWays_memo(int[][] maze,int sr,int sc,int dr,int dc,int[][] dir,int[][] dp){
        if(sr == dr && sc == dc){
            return dp[sr][sc] = 1;
        }
        if(dp[sr][sc] != 0){
            return dp[sr][sc];
        }
        int ways = 0;
        for(int i = 0 ; i < dir.length ; i++){
            int r = sr + dir[i][0];
            int c = sc + dir[i][1];
            while(r <= dr && c <= dc){
               ways += mazePathJumpWays_memo(maze , r , c , dr , dc , dir , dp);
               r += dir[i][0];
               c += dir[i][1];
            }
        }
        return dp[sr][sc] = ways;
    }
    
    public static int mazePathJumpWays_tab(int[][] maze,int SR,int SC,int DR,int DC,int[][] dir,int[][] dp){
        for(int sr = DR ; sr >= SR ; sr--){
            for(int sc = DC ; sc >= SC ; sc--){
                if(sr == DR && sc == DC){
                    dp[sr][sc] = 1;
                    continue;
                }
                int ways = 0;
                for(int i = 0 ; i < dir.length ; i++){
                    int r = sr + dir[i][0];
                    int c = sc + dir[i][1];
                    while(r <= DR && c <= DC){
                        ways += dp[r][c];
                        r += dir[i][0];
                        c += dir[i][1];
                    }
                }
                dp[sr][sc] = ways;
            }
        }
        return dp[SR][SC];
    }
 
-> climb 3 stairs ways

    public static int climb3StairsWays_rec(int n){
        if(n == 0){
            return 1;
        }
        int ways = 0;
        for(int i = 1 ; i <= 3 ; i++){
            if(n - i >= 0){
                ways += climb3StairsWays_rec(n-i);
            }
        }
        return ways;
    }
    
    public static int climb3StairsWays_memo(int n,int[] dp){
        if(n == 0){
            return dp[n] = 1;
        }
        if(dp[n] != 0){
            return dp[n];
        }
        int ways = 0;
        for(int i = 1 ; i <= 3 ; i++){
            if(n - i >= 0){
                ways += climb3StairsWays_memo(n-i,dp);
            }
        }
        return dp[n] = ways;
    }
    
    public static int climb3StairsWays_tab(int N,int[] dp){
        for(int n = 0 ; n <= N ; n++){
            if(n == 0){
                dp[n] = 1;
                continue;
            }
            int ways = 0;
            for(int i = 1 ; i <= 3 ; i++){
                if(n - i >= 0){
                    ways += dp[n-i];
                }
            }
            dp[n] = ways;
        }
        return dp[N];
    }
  
