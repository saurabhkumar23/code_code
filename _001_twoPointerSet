---> Question solving flow :

  -> think faith >> draw recursive tree >> write recursive code >> 
     do memoization >> observation >> do tabulation >> optimization ~sometimes
  -> first flow takes the almost time and the base of DP, second flow hardly takes 3 minutes.
  -> memoization or tabulation ? - always invest yourself in memoization. intuition never comes by tabulation. also memo to tab hardly takes 3 minutes via only small changes.
  -> tabulation ? - memoization is actual DP, but when if mujhe kuch pattern observe ho raha hai. ye to shayad me iteratively bhi kar sakta hu. that is tabulation.
  -> real life dp ? - cooking something new via Yt takes time only for the first time.
  -> dp says if you have already evaluation a solution to a problem then don't solve it again, just save that solution into some space and utilise it
  
 -> fibonacci 
 
    public static int fibo_rec(int n){
        if(n <= 1){
            return n;
        }
        int fib = fibo_rec(n-1) + fibo_rec(n-2);
        return fib;
    }
    
     public static int fibo_memo(int n,int[] dp){
        if(n <= 1){
            return dp[n] = n;
        }
        if(dp[n] != 0){
            return dp[n];
        }
        int fib = fibo_memo(n-1,dp) + fibo_memo(n-2,dp);
        return dp[n] = fib;
    }
    
     public static int fibo_tab(int N,int[] dp){
        for(int n = 0 ; n <= N ; n++){
            if(n <= 1){
                dp[n] = n;
                continue;
            }
            int fib = dp[n-1] + dp[n-2];
            dp[n] = fib;
        }
        return dp[N];
    }
    
 -> maze path
 
     public static int mazePathWays_rec(int[][] maze,int sr,int sc,int dr,int dc,int[][] dir){
        if(sr > dr || sc > dc){
            return 0;
        }
        if(sr == dr && sc == dc){
            return 1;
        }
        int ways = 0;
        for(int i = 0 ; i < 3 ; i++){
            ways += mazePathWays_rec(maze , sr + dir[i][0] , sc + dir[i][1] ,dr,dc,dir);
        }
        return ways;
    }

    public static int mazePathWays_memo(int[][] maze,int sr,int sc,int dr,int dc,int[][] dir,int[][] dp){
        if(sr > dr || sc > dc){
            return 0;
        }
        if(sr == dr && sc == dc){
            return dp[sr][sc] = 1;
        }
        if(dp[sr][sc] != 0){
            return dp[sr][sc];
        }
        int ways = 0;
        for(int i = 0 ; i < 3 ; i++){
            ways += mazePathWays_memo(maze , sr + dir[i][0] , sc + dir[i][1] ,dr,dc,dir,dp);
        }
        return dp[sr][sc] = ways;
    }

    public static int mazePathWays_tab(int[][] maze,int SR,int SC,int DR,int DC,int[][] dir,int[][] dp){
        for(int sr = DR ; sr >= SR ; sr--){
            for(int sc = DC ; sc >= SC ; sc--){
                if(sr == DR && sc == DC){
                    dp[sr][sc] = 1;
                    continue;
                }
                int ways = 0;
                for(int i = 0 ; i < 3 ; i++){
                    int c = sc + dir[i][0];
                    int r = sr + dir[i][1];
                    if(r <= DR && c <= DC){
                        ways += dp[r][c];
                    }
                }
                dp[sr][sc] = ways;
            }
        }
        return dp[SR][SC];
    }
    
    
